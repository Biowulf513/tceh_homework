# ===============лайвхаки==============
'''
http://pythontutor.com/visualize.html#mode=edit

GLOBAL_LIST = []  - глобальная переменная  (все буквы большие)

values = [1, 2, 3, 4]
function(*values) - передаём все занчения переменной (извлекая из списка разбиваясь на длинну (4 элемента))

ininstance(obj, type) - является ли типом
callable(obj) - является ли функцией
'''
# ==================ООП=================
'''

def func(obj)
    super().функция у класса предка(obj) - выполняет функцию целиком
    ... Новая логика
пример super().log(*values)


'''
# ================Магия=================
'''
dir(class) - проказать все функции класса

def __inid__(self) - Иницилизация (конструктор класса)

.__mro__ - показать порядок наследования
.__dict__ - выведет все внутренние значения класса

id(1) - посмотреть ячейку памяти

type(self).__name__ - вывести название класса

'''
# ============Генераторы===============
def gen():
    a, b = 0, 1
    while True:
        yield a # Аналог return
        a, b = b, a + b

x = gen()
next(x)  # вызов следующей итерации
next(x)  # вызов следующей итерации
next(x)  # вызов следующей итерации

# ==========короткая запись=============
'''

                IF
result = "Fizz Buzz" if (number%15 == 0) else ( "Fizz" if number%3==0 else ("Buzz" if number%5 == 0 else str(number)))

                FOR
Pizza.validate_topping(i) for i in ingredients)
'''
# ================Сахар=================
'''

s = [w for w in range(1,14)]
> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]

s = [w for w in range(1,14) if w % 2 == 0]
> [2, 4, 6, 8, 10, 12]

d = lambda x, y: x + y
d(1, 2)
> 3

#map - выполняет функцию для каждого объекта из массива входных параметров

def work(value):
    return value*2

i = [1,2,3,4,5]
m = map(work, i)
print(list(m))
# > [2, 4, 6, 8, 10]


# filter - оставляет из массива только что удовлетворяет условию

f = filter(lambda x : x > 3, [1, 2, 3, 4, 5])
print(list(f))
# > [4, 5]

# reduce - выполняет функцию для каждого объекта
# из массива входных параметров, оперируя остатком

from functools import reduce

r = [1, 2, 3, 4, 5]

result = reduce(lambda x, y: x + y, r)
print(result)
# > 15

'''
# ==============Декораторы==============
'''
'''


# ==================Re==================
'''
https://tproger.ru/translations/regular-expression-python/

re.match(pattern, string):
Этот метод ищет по заданному шаблону в начале строки.

re.search(pattern, string):
Этот метод похож на match(), но он ищет не только в начале строки.

re.findall(pattern, string):
Этот метод возвращает список всех найденных совпадений. 

re.split(pattern, string, [maxsplit=0]):
Этот метод разделяет строку по заданному шаблону.

re.sub(pattern, repl, string):
Этот метод ищет шаблон в строке и заменяет его на указанную подстроку.

re.compile(pattern, repl, string):
Мы можем собрать регулярное выражение в отдельный объект, который может быть использован для поиска.

Оператор	Описание
.	Один любой символ, кроме новой строки \n.
?	0 или 1 вхождение шаблона слева
+	1 и более вхождений шаблона слева
*	0 и более вхождений шаблона слева
\w	Любая цифра или буква (\W — все, кроме буквы или цифры)
\d	Любая цифра [0-9] (\D — все, кроме цифры)
\s	Любой пробельный символ (\S — любой непробельнй символ)
\b	Граница слова
[..]	Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках)
\	Экранирование специальных символов (\. означает точку или \+ — знак «плюс»)
^ и $	Начало и конец строки соответственно
{n,m}	От n до m вхождений ({,m} — от 0 до m)
a|b	Соответствует a или b
()	Группирует выражение и возвращает найденный текст
\t, \n, \r	Символ табуляции, новой строки и возврата каретки соответственно
'''
# ================timeit================
'''

модуль позволяет измерить время выполнения небольших фрагментов кода с целью оптимизации программы.

class timeit.Timer([stmt='pass'][, setup='pass'][, timer=<timer function>])
Параметры:
stmt – строка кода, для которого измеряется время выполнения
setup – строка кода, которая должна выполниться перед измерением времени
timer –

'''